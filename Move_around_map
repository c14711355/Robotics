#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//Movement & line counting

#define ROW 9
#define COL 7



//Function prototypes
void turn ( float time, int speed1, int speed2 , int * direction);
void straight (  int speed , int * warning , int thresholdValue , int *direction , int *countValue);
void cal_threshold ( int *thresholdValue );

int current_position ( int *direction );
int create_map ( int * row_position , int * col_position , int *direction);


task main()
{



   /***********************Start Variable Declaration****************************/

    //Variables for line counting
	int thresholdValue;
 	int countValue = 0;
 	//int lastSeen = 1;


    //Variables for diameter
	float diameter_between_wheels = 115;       //Diameter Between both wheels
	float diameter_of_wheel = 58;             //Diameter Of wheels


    //Variables for Turn accuracy
	float one_degree ;                      //Calculate a 1 degree turn
	float roations;                        // Rotations = 1 Degree turn * 360 for 1 full turn
	float no_turns = .25;                 //Used to Rotate 90 degrees


    //variables for speed
	int speed_straight = 50;
	int speed_turn1 = 20;
	int speed_turn2 = -20;

	//Variables for map
   int direction = 0;

   //Waring variables
   int warning;

   /***********************End Variable Declaration****************************/




   /***********************Start Main******************************************/

	//Calculate Rotations in Degrees
	//Divide Diameter Between wheels by diameter of wheel to calculate a one degree rotation
	one_degree = diameter_between_wheels / diameter_of_wheel;
	roations = 360 * one_degree * no_turns;


	//call function to calculate threshold
	cal_threshold (  &thresholdValue );


	//Call Function to turn left
	turn ( roations , speed_turn1 , speed_turn2 , &direction );


    //Main Control Loop  ************************************************************************************
	int infinite = 1;
	while( infinite == 1 )
	{

		warning = 0;


		//Call Function move straight

		straight (  speed_straight , & warning , thresholdValue , & direction , &countValue);












/****************************************************************/
/*
/*					If Robot is at edge of map turn
/****************************************************************/

		if (warning == 0)   //No Warning
		{

			//Position is ok

		}//End if()

		else if (warning == 1)   //Last Row position
		{

			//turn right
			turn ( roations , speed_turn2 , speed_turn1 , &direction );

		}//End if()

		else if (warning == 2)   //First Row Position
		{

			//turn right
			turn ( roations , speed_turn2 , speed_turn1 , &direction );

		}//End if()

		else if (warning == 3)   //Last Column Position
		{

			//turn right
			turn ( roations , speed_turn2 , speed_turn1 , &direction );

		}//End if()

		else if (warning == 4)   //First Column Position
		{

			//turn right
			turn ( roations , speed_turn2 , speed_turn1 , &direction );

		}//End if()


			warning = 0;

if (direction != -1)
			nxtDisplayStringAt(1, 31, "Direction = %d" , direction);

			/**************************Stop at start Position*******************************************/
			//Use Direction Value (Temp)
			if ( direction == 5 )
			{
				//turn right
				turn ( roations , speed_turn2 , speed_turn1 , &direction );
				break;
		  }//end if
		  /**************************End Stop at start***********************************************/


	}//end while()

}//end main()









//Implement Function To Turn

void turn ( float time, int speed1, int speed2 , int *direction)
{

	int difference = 1;

	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorB] = 0;


	/**********************Turn left***************************/

	  static int count = 0;
		if (count == 0)
		{

			*direction = *direction - 1;


			//if direction is 4 reset to zero
			if (*direction == -4)
			{
				*direction = 0;

			}//end if
			count = 1;





		while (nMotorEncoder[motorB] < time)
		{

			motor[motorB] = speed1;  //MotorB = Right Motor
			motor[motorC] = speed2 - difference;


		}//end while()

	}//end outer if()
	//*********************End Left Turn******************







	/**************Turn Right***************************/

	if ( speed1 < 0 )  //If speed is a negative value
	{


		if (count == 0)
		{

			*direction = *direction + 1;


			//if direction is 4 reset to zero
			if (*direction == 4)
			{
				*direction = 0;

			}//end if
			count = 1;
		}//end outer if




		while (nMotorEncoder[motorB] > - time)
		{
			motor[motorB] = speed1;
			motor[motorC] = speed2;

		}//end while()

	}//end if right

	//**************End Turn Right**********************************

}//end turn()









//Implement Function To move straight

void straight (  int speed , int * warning , int thresholdValue , int *direction , int *countValue)
{

    //int difference = 1;

int lastSeen = 1;



//Warning , Direction , threshold


        //Sync motors
        nSyncedMotors = synchCB;
        nSyncedTurnRatio = 100;

        motor[motorB] = speed;  //MotorB = Right Motor
        //motor[motorC] = speed - difference;  //Sub the difference to move straight

        nSyncedMotors = synchNone;




        //While surface detected is dark
		while (SensorValue(lightSensor) < thresholdValue)
		{

            //Only increment once when dark detected
			if (lastSeen == 1)
			{
				* countValue ++;
				lastSeen= 0;


				//Call Fxn to Change position
				* warning = current_position ( direction );

			}//end if

		}//end while
		lastSeen = 1;


}//end straight fxn















//Function prototypes
void cal_threshold ( int *thresholdValue )
{

		int lightValue;
		int darkValue;
		int sumValue;


		int test = 1;

		if (test == 0)
        {

            while(SensorValue(touchSensor)==0)
            {
                nxtDisplayStringAt(0, 31, "Read Light Now");
            }
            lightValue=SensorValue(lightSensor);

            wait1Msec(1000);

            while(SensorValue(touchSensor)==0)
            {
                nxtDisplayStringAt(0, 31, "Read Dark Now");
            }

            darkValue=SensorValue(lightSensor);

            sumValue=lightValue+darkValue;
            *thresholdValue = sumValue/2;

            wait1Msec(1000);

            while(SensorValue(touchSensor)==0)
            {
            	nxtDisplayStringAt(0, 31, "Ready To Start");
            }

        }//end test auto


    //Only for Virtual worlds:
	if (test == 1)
    {
        *thresholdValue = 80;
    }


}//end fxn








/****************************************************************************/
/*
/*
/*
/****************************************************************************/
int current_position ( int *direction )
{

    static int row_position = ROW -1;
    static int col_position = 4;

    //Value returned from create map to check if position of robot is at edge
    int warning = 0;


			nxtDisplayStringAt(2, 31, "Direction = --%d--" , * direction);    /****************************************************************************/
			wait1Msec(1000);


    	if (* direction == 0)  //if robot Moves straight
    	{
    		 row_position --;

    	}//end case

        else if (* direction == 1 || * direction == -3  ) //if robot Moves Right
    	{
    		 ++ col_position;


    	}//end case


        else if (* direction == 2 || * direction == -2  )  //if robot Moves Backwards
        {
            ++ row_position;


        }//end case



        else if (* direction == 3 || * direction == -1  )//if robot Moves Left
        {
             -- col_position  ;


        }//end case

        //If Error Spin in a fast circle
        else
        {
        	motor[motorB] = -100;  //MotorB = Right Motor
          motor[motorC] = 100;
          wait1Msec(3000);
        }//end default (error)




        /*********************************************/
        /*********************************************/
        /*********************************************/
        /*********************************************/


    //call function create_map
    warning = create_map ( & row_position , & col_position   , direction);
    if ( warning == 1)//Last Row Position
    {
        //Turn Robot Left or right
    }
    else if ( warning == 2)//First Row Position
    {
        //Turn Robot right  *****************************************************************************
    		return 2;
    }
    else if ( warning == 3)//Last Column Position
    {
        //Turn Robot Left or right
    }//end esle if
    else if ( warning == 4)//First Column Position
    {
        //Turn Robot Left or right
    }//end esle if
    else
    {
        //Robot Position is Ok
    		return 0;
    }


}//end current Position()











/****************************************************************************/
/*
/*
/*
/****************************************************************************/
int create_map ( int * row_position , int * col_position , int *direction )
{


	int i , j ;
	static char map[ROW][COL];
	static int once = 1;


	//Only Initilise Array Once
	//Fill Array with a dash
	if (once == 1 )
	{
		for ( i = 0 ; i < ROW ; i ++)
		{
			for ( j = 0 ; j < COL ; j++ )
			{
				map[i][j] = '-';

			}//end inner for

		}//end outer for

		//Initilise Start Position
		map[ROW - 1][4] = 'S';

		once = 0;
	}//end if


	//Initilise current Position
	map[ *row_position ][ *col_position] = 'C';





	/********************************************/
	/*If Robot is back at start
	/******************************************
	if ( *row_position == ROW - 1 && *col_position == 1)
	{

		*direction = 5;

	}//end if ()

	/********************************************/






	/********************************************/
	/*Check if the robot is at the edge of map
	/******************************************/

	if ( *row_position == ROW - 1  && (*direction == 2 || *direction == - 2) )  //Last Row Position
	{
		return 1;
	}//end main()
	else if ( *row_position == 0 && *direction == 0  )		//First Row Position
	{
		return 2;
	}//end main()
	else if ( *col_position == COL - 1 && (*direction == 1 || *direction == - 3))  //Last Column Position
	{
		return 3;
	}//end main()
	else if ( *col_position == 0 && (*direction == 3 || *direction == - 1))		//First Column Position
	{
		return 4;
	}//end main()
	else
	{
		//Position is ok
		return 0;
	}//end else()

	/******************End Check**************************/


}
