/******************************\
|*     Program To Move        *|
|*   to Each Corner of map    *|
\******************************/


//Function Prototypes
void current_position ( int * direction );
void turn (  int * direction , int move );



//Symbolic Names
#define ROW 9
#define COL 7




//Implement Main()
task main()
{

	int exit = 1;            //Infinite while loop in main
	int one_cell = 600;      //nMotor Encoder distance of one cell
	int direction = 0;       //Keeps track of the direction robot is facing




	/****************************************\
	|*        Start Infinite Loop           *|
	\****************************************/
	while (exit == 1)
	{

		nMotorEncoder[motorB] = 0;
		nMotorEncoder[motorC] = 0;


		/****************************************\
		|*         Move Straight one Cell       *|
		\****************************************/

		//Sync motors
		nSyncedMotors = synchCB;
		nSyncedTurnRatio = 100;

		while ( nMotorEncoder[motorB] < one_cell )   //Move distance of 1 Cell
		{
			motor[motorB] = 49;  //MotorB = Right Motor
			motor[motorC] = 49;  

		}//end while

		nSyncedMotors = synchNone;
		nMotorEncoder[motorB] = 0;

		motor[motorB] = 0;
		motor[motorC] = 0;


		/****************************************\
		|*     End Move Straight one Cell       *|
		\****************************************/






		/****************************************\
		|*     Change position in map           *|
		\****************************************/
		current_position ( & direction );



	}//end infinite while


}//end main()







/************************************************************\
|*     Implent Function to Change Current Position          *|
|*                                                          *|
|*     Function Description:				                        *|
|*                                                          *|
|*                                                          *|
\************************************************************/
void current_position ( int * direction )
{

	/*****************************************\
	|*   Set the Current Position as         *|
	|*           Start position              *|
	\*****************************************/

	static int row_position = ROW -1;
	static int col_position = 4;

	//Declare Variables
	int i , j ;
	static char map[ROW][COL];
	static int once = 1;
	int move;  									 //Value passed to function to turn left or right




	switch (* direction)   //Select case based on direction the robot is facing
	{

	case 0:  //if robot Moves straight
		{
			row_position -= 1;
			break;
		}//end case



	//if robot is facing Right
	case 1:
	case -3:
		{
			col_position += 1;

			break;
		}//end case



	//if robot is facing backwards Backwards
	case 2:
	case -2:
		{
			row_position += 1;

			break;
		}//end case



	//if robot is facing Left
	case 3:
	case -1:
		{
			col_position -= 1  ;

			break;
		}//end case



	//If Error Spin in a fast circle???
	default :
		{
			motor[motorB] = -100;  //MotorB = Right Motor
			motor[motorC] = 100;
			wait1Msec(3000);
		}//end default (error)

	}//end switch



	/***********************************\
	|*		Initilise 2D Array           *|
	|*    with a dash - Only Once      *|
	\***********************************/

	if (once == 1 )
	{
		for ( i = 0 ; i < ROW ; i ++)
		{
			for ( j = 0 ; j < COL ; j++ )
			{
				map[i][j] = '-';

			}//end inner for
		}//end outer for

		//Initilise Start Position
		map[ROW - 1][4] = 'S';

		//Change condition
		once = 0;
	}//end if



	/***********************************\
	|*		END  -  Initilise            *|
	|*            2D Array             *|
	\***********************************/





	//Initilise current Position
	map[ row_position ][ col_position] = 'C';
	
	
	
	
	/***********************************\
	|*		Check if Robot is at         *|
	|*       Edge of map               *|
	\***********************************/
	
	if ( row_position == ROW - 1  && (*direction == 2 || *direction == - 2) )  //Last Row Position && direction is facing backwards
	{
		
		//Turn Right
		move = 1;
		//Implement Function to turn
		turn (  direction ,  move );
		
	}//end main()
	else if ( row_position == 0 && *direction == 0  )		//First Row Position && facing straight
	{
		
		//Turn Right
		move = 1;
		//Implement Function to turn
		turn (  direction ,  move );
		
	}//end main()
	if ( col_position == COL - 1 && (*direction == 1 || *direction == - 3))  //Last Column Position and facing to the right
	{
		
		//Turn Right
		move = 1;
		//Implement Function to turn
		turn (  direction ,  move );
		
	}//end main()
	else if ( col_position == 0 && (*direction == 3 || *direction == - 1))		//First Column Position and facing to the left
	{
		
		//Turn Right
		move = 1;
		//Implement Function to turn
		turn (  direction ,  move );
		
	}//end main()
	
	
	
	/***********************************\
	|*	     	End Check                *|
	|*                                 *|
	\***********************************/


}//end current position() fxn











/************************************************************\
|*     Implent Function to Turn                             *|
|*                                                          *|
|*     Function Description:				                        *|
|*                                                          *|
|*                                                          *|
\************************************************************/

void turn (  int * direction , int move )
{

	static int once = 0;
	static float rotations;                     // Rotations = 1 Degree turn * 360 for 1 full turn

	/*******************************************************************\
	|*       Change so robot moves                                     *|
	|*     forward :: Turns :: Moves back                              *|
	\*******************************************************************/

	/******************************\
	|*    Calculate 90 degree     *|
	|*    Rotation                *|
	\******************************/
	if (once == 0 )
	{

		//Variables for diameter
		float diameter_between_wheels = 115;       //Diameter Between both wheels
		float diameter_of_wheel = 58;              //Diameter Of wheels


		//Variables for Turn accuracy
		float one_degree ;                         //Calculate a 1 degree turn
		float no_turns = .25;                      //Used to Rotate 90 degrees

		//Calculate Rotations in Degrees
		//Divide Diameter Between wheels by diameter of wheel to calculate a one degree rotation
		one_degree = diameter_between_wheels / diameter_of_wheel;
		rotations = 360 * one_degree * no_turns;

		once = 1;

	}//end Calculate rotation


	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorB] = 0;



	/*********************************\
	|*         Turn Left             *|
	\*********************************/

	if ( move == 1 )
	{

		// Change Direction
		*direction -= 1;

		// Reset Direction
		if (*direction == -4)
		{
			*direction = 0;
		}//end if


		// Implement Left Turn
		while ( nMotorEncoder[motorB] < rotations )
		{
			motor[motorB] = 20;  //MotorB = Right Motor
			motor[motorC] = -20;
		}//end while()
	}//end outer if()

	/*********************************\
	|*        END Turn Left          *|
	\*********************************/








	/*********************************\
	|*         Turn Right            *|
	\*********************************/

	if ( move == 0 )
	{
			// Change Direction
			*direction += 1;

			//if direction is 4 reset to zero
			if (*direction == 4)
			{
				*direction = 0;
			}//end if


		// Implement Right Turn
		while (nMotorEncoder[motorB] > - rotations)
		{
			motor[motorB] = -20;
			motor[motorC] = 20;
		}//end while()
	}//end if right

	/*********************************\
	|*        END Turn Right         *|
	\*********************************/

}//end turn()fxn
